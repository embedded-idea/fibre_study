/*[# This is the original template, thus the warning below does not apply to this file #]
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains base classes that correspond to the interfaces defined in
 * your interface file. The objects you publish should inherit from these
 * interfaces.
 *
 */
#ifndef __FIBRE_INTERFACES_HPP
#define __FIBRE_INTERFACES_HPP

#include <stdint.h>
#include <tuple>
#include <fibre/../../property.hpp>

[[userdata.c_preamble]]

[%- macro intf_name(intf) %]
[%- if intf.builtin %]fibre::Property<[['const ' if intf.mode == 'readonly']][[type_name(intf.value_type)]]>
[%- else %]
[%- for elem in intf.name %][[elem | to_pascal_case]][['_' if not loop.last]][% endfor %]Intf
[%- endif %]
[%- endmacro %]

[%- macro wrapper_name(intf) %]
[%- if intf.builtin %]fibre::Property<[['const ' if intf.mode == 'readonly']][[type_name(intf.value_type)]]>
[%- else %]
[%- for elem in intf.name %][[elem | to_pascal_case]][['_' if not loop.last]][% endfor %]Wrapper
[%- endif %]
[%- endmacro %]

[%- macro type_name(type) %]
[%- if type.c_name %][[type.c_name]][% else %]unknown name for [[type]][% endif %]
[%- endmacro %]

[%- macro rettype(func) %]
[%- if not func.out -%]
void
[%- elif func.out | length == 1 -%]
[[type_name((func.out.values() | first).type)]]
[%- else -%]
std::tuple<[% for arg in func.out.values() %][[type_name(arg.type)]][[', ' if not loop.last]][% endfor %]>
[%- endif -%]
[%- endmacro %]

[% for intf in interfaces.values() %]
[%- if not intf.builtin %]
class [[intf_name(intf)]];
template<typename T> class [[wrapper_name(intf)]];
[%- endif %]
[%- endfor %]

[% for intf in interfaces.values() %]
[%- if not intf.builtin %]
class [[intf_name(intf)]][% if intf.implements %] :[%- for base_intf in intf.implements %] public [[base_intf.c_name]][% endfor %][% endif %] {
public:
[%- for enum in intf.enums %]
    enum [[enum.name | to_pascal_case]] {
[%- for k, value in enum['values'].items() %]
        [[((enum.name | to_macro_case) + "_" + (k | to_macro_case)).ljust(32)]] = [% if enum.is_flags %]0x[['%08x' | format(value.value)]][% else %][[value.value]][% endif %],
[%- endfor %]
    };
[%- endfor %]

[%- for func in intf.functions.values() %]
    virtual [[rettype(func)]] [[func.name[-1]]]([% for name, in in func.in.items() %][% if loop.index0 %][[type_name(in.type)]] [[name]][[', ' if not loop.last]][% endif %][% endfor %]) = 0;
[%- endfor %]

[%- for name, attr in intf.attributes.items() %]
    virtual [[intf_name(attr.type)]]* get_[[name]]() = 0;
[%- endfor %]
};
[%- endif %]
[% endfor %]


[% for intf in interfaces.values() %]
[%- if not intf.builtin %]
template<typename T>
struct [[wrapper_name(intf)]] : [[intf_name(intf)]] {
[%- for name, attr in intf.attributes.items() %]
    template<typename U, typename TMem = decltype(std::declval<U>().[[name]]_)> static constexpr bool Has[[name | to_pascal_case]](int) { return true; }
    template<typename U> static constexpr bool Has[[name | to_pascal_case]](...) { return false; }
[%- endfor %]
[%- for name, func in intf.functions.items() %]
    template<typename U, typename TRet = decltype(([[rettype(func)]])std::declval<U>().[[name]]([% for name, in in func.in.items() %][% if loop.index0 %]std::declval<[[type_name(in.type)]]>()[[', ' if not loop.last]][% endif %][% endfor %]))> static constexpr bool Has[[name | to_pascal_case]](int) { return true; }
    template<typename U> static constexpr bool Has[[name | to_pascal_case]](...) { return false; }
[%- endfor %]

    [[wrapper_name(intf)]](T& impl) : impl_(&impl) {}
[% for name, attr in intf.attributes.items() %]
    virtual [[intf_name(attr.type)]]* get_[[name]]() final {
        static_assert(Has[[name | to_pascal_case]]<T>(0), "T cannot be cast to interface [[intf.name.get_fibre_name()]]: No member [[name]]_. See details below.");
        return &[[name]]_;
    }
[% endfor %][% for name, func in intf.functions.items() %]
    [[rettype(func)]] [[name]]([% for name, in in func.in.items() %][% if loop.index0 %][[type_name(in.type)]] [[name]][[', ' if not loop.last]][% endif %][% endfor %]) final {
        static_assert(Has[[name | to_pascal_case]]<T>(0), "T cannot be cast to interface [[intf.name.get_fibre_name()]]: No matching overload for [[name]](). See details below.");
        return impl_->[[name]]([% for name in func.in.keys() %][% if loop.index0 %][[name]][[', ' if not loop.last]][% endif %][% endfor %]);
    }
[% endfor %]
    T* impl_;
[%- for name, attr in intf.attributes.items() %]
[%- if attr.type.builtin %]
    [[wrapper_name(attr.type)]] [[name]]_{&impl_->[[name]]_};
[%- else %]
    [[wrapper_name(attr.type)]]<decltype(impl_->[[name]]_)> [[name]]_{impl_->[[name]]_};
[%- endif %]
[%- endfor %]
};
[%- endif %]
[% endfor %]

[%- for _, enum in value_types.items() %]
[%- if enum.is_flags %]
// this is technically not thread-safe but practically it might be
inline [[enum.c_name]] operator | ([[enum.c_name]] a, [[enum.c_name]] b) { return static_cast<[[enum.c_name]]>(static_cast<std::underlying_type_t<[[enum.c_name]]>>(a) | static_cast<std::underlying_type_t<[[enum.c_name]]>>(b)); }
inline [[enum.c_name]] operator & ([[enum.c_name]] a, [[enum.c_name]] b) { return static_cast<[[enum.c_name]]>(static_cast<std::underlying_type_t<[[enum.c_name]]>>(a) & static_cast<std::underlying_type_t<[[enum.c_name]]>>(b)); }
inline [[enum.c_name]] operator ^ ([[enum.c_name]] a, [[enum.c_name]] b) { return static_cast<[[enum.c_name]]>(static_cast<std::underlying_type_t<[[enum.c_name]]>>(a) ^ static_cast<std::underlying_type_t<[[enum.c_name]]>>(b)); }
inline [[enum.c_name]]& operator |= ([[enum.c_name]] &a, [[enum.c_name]] b) { return reinterpret_cast<[[enum.c_name]]&>(reinterpret_cast<std::underlying_type_t<[[enum.c_name]]>&>(a) |= static_cast<std::underlying_type_t<[[enum.c_name]]>>(b)); }
inline [[enum.c_name]]& operator &= ([[enum.c_name]] &a, [[enum.c_name]] b) { return reinterpret_cast<[[enum.c_name]]&>(reinterpret_cast<std::underlying_type_t<[[enum.c_name]]>&>(a) &= static_cast<std::underlying_type_t<[[enum.c_name]]>>(b)); }
inline [[enum.c_name]]& operator ^= ([[enum.c_name]] &a, [[enum.c_name]] b) { return reinterpret_cast<[[enum.c_name]]&>(reinterpret_cast<std::underlying_type_t<[[enum.c_name]]>&>(a) ^= static_cast<std::underlying_type_t<[[enum.c_name]]>>(b)); }
inline [[enum.c_name]] operator ~ ([[enum.c_name]] a) { return static_cast<[[enum.c_name]]>(~static_cast<std::underlying_type_t<[[enum.c_name]]>>(a)); }
[%- endif %]
[%- endfor %]



#endif // __FIBRE_INTERFACES_HPP