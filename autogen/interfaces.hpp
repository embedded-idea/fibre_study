/*
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains base classes that correspond to the interfaces defined in
 * your interface file. The objects you publish should inherit from these
 * interfaces.
 *
 */
#ifndef __FIBRE_INTERFACES_HPP
#define __FIBRE_INTERFACES_HPP

#include <stdint.h>
#include <tuple>
#include <fibre/../../property.hpp>




class TestIntf1Intf;
template<typename T> class TestIntf1Wrapper;
class TestIntf1_SubobjIntf;
template<typename T> class TestIntf1_SubobjWrapper;


class TestIntf1Intf {
public:
    virtual void func00() = 0;
    virtual uint32_t func01() = 0;
    virtual std::tuple<uint32_t, uint32_t> func02() = 0;
    virtual void func10(uint32_t in1) = 0;
    virtual uint32_t func11(uint32_t in1) = 0;
    virtual std::tuple<uint32_t, uint32_t> func12(uint32_t in1) = 0;
    virtual void func20(uint32_t in1, uint32_t in2) = 0;
    virtual uint32_t func21(uint32_t in1, uint32_t in2) = 0;
    virtual std::tuple<uint32_t, uint32_t> func22(uint32_t in1, uint32_t in2) = 0;
    virtual fibre::Property<const uint32_t>* get_prop_uint32() = 0;
    virtual fibre::Property<uint32_t>* get_prop_uint32_rw() = 0;
    virtual TestIntf1_SubobjIntf* get_subobj() = 0;
};



class TestIntf1_SubobjIntf {
public:
    virtual uint32_t subfunc() = 0;
};




template<typename T>
struct TestIntf1Wrapper : TestIntf1Intf {
    template<typename U, typename TMem = decltype(std::declval<U>().prop_uint32_)> static constexpr bool HasPropUint32(int) { return true; }
    template<typename U> static constexpr bool HasPropUint32(...) { return false; }
    template<typename U, typename TMem = decltype(std::declval<U>().prop_uint32_rw_)> static constexpr bool HasPropUint32Rw(int) { return true; }
    template<typename U> static constexpr bool HasPropUint32Rw(...) { return false; }
    template<typename U, typename TMem = decltype(std::declval<U>().subobj_)> static constexpr bool HasSubobj(int) { return true; }
    template<typename U> static constexpr bool HasSubobj(...) { return false; }
    template<typename U, typename TRet = decltype((void)std::declval<U>().func00())> static constexpr bool HasFunc00(int) { return true; }
    template<typename U> static constexpr bool HasFunc00(...) { return false; }
    template<typename U, typename TRet = decltype((uint32_t)std::declval<U>().func01())> static constexpr bool HasFunc01(int) { return true; }
    template<typename U> static constexpr bool HasFunc01(...) { return false; }
    template<typename U, typename TRet = decltype((std::tuple<uint32_t, uint32_t>)std::declval<U>().func02())> static constexpr bool HasFunc02(int) { return true; }
    template<typename U> static constexpr bool HasFunc02(...) { return false; }
    template<typename U, typename TRet = decltype((void)std::declval<U>().func10(std::declval<uint32_t>()))> static constexpr bool HasFunc10(int) { return true; }
    template<typename U> static constexpr bool HasFunc10(...) { return false; }
    template<typename U, typename TRet = decltype((uint32_t)std::declval<U>().func11(std::declval<uint32_t>()))> static constexpr bool HasFunc11(int) { return true; }
    template<typename U> static constexpr bool HasFunc11(...) { return false; }
    template<typename U, typename TRet = decltype((std::tuple<uint32_t, uint32_t>)std::declval<U>().func12(std::declval<uint32_t>()))> static constexpr bool HasFunc12(int) { return true; }
    template<typename U> static constexpr bool HasFunc12(...) { return false; }
    template<typename U, typename TRet = decltype((void)std::declval<U>().func20(std::declval<uint32_t>(), std::declval<uint32_t>()))> static constexpr bool HasFunc20(int) { return true; }
    template<typename U> static constexpr bool HasFunc20(...) { return false; }
    template<typename U, typename TRet = decltype((uint32_t)std::declval<U>().func21(std::declval<uint32_t>(), std::declval<uint32_t>()))> static constexpr bool HasFunc21(int) { return true; }
    template<typename U> static constexpr bool HasFunc21(...) { return false; }
    template<typename U, typename TRet = decltype((std::tuple<uint32_t, uint32_t>)std::declval<U>().func22(std::declval<uint32_t>(), std::declval<uint32_t>()))> static constexpr bool HasFunc22(int) { return true; }
    template<typename U> static constexpr bool HasFunc22(...) { return false; }

    TestIntf1Wrapper(T& impl) : impl_(&impl) {}

    virtual fibre::Property<const uint32_t>* get_prop_uint32() final {
        static_assert(HasPropUint32<T>(0), "T cannot be cast to interface TestIntf1: No member prop_uint32_. See details below.");
        return &prop_uint32_;
    }

    virtual fibre::Property<uint32_t>* get_prop_uint32_rw() final {
        static_assert(HasPropUint32Rw<T>(0), "T cannot be cast to interface TestIntf1: No member prop_uint32_rw_. See details below.");
        return &prop_uint32_rw_;
    }

    virtual TestIntf1_SubobjIntf* get_subobj() final {
        static_assert(HasSubobj<T>(0), "T cannot be cast to interface TestIntf1: No member subobj_. See details below.");
        return &subobj_;
    }

    void func00() final {
        static_assert(HasFunc00<T>(0), "T cannot be cast to interface TestIntf1: No matching overload for func00(). See details below.");
        return impl_->func00();
    }

    uint32_t func01() final {
        static_assert(HasFunc01<T>(0), "T cannot be cast to interface TestIntf1: No matching overload for func01(). See details below.");
        return impl_->func01();
    }

    std::tuple<uint32_t, uint32_t> func02() final {
        static_assert(HasFunc02<T>(0), "T cannot be cast to interface TestIntf1: No matching overload for func02(). See details below.");
        return impl_->func02();
    }

    void func10(uint32_t in1) final {
        static_assert(HasFunc10<T>(0), "T cannot be cast to interface TestIntf1: No matching overload for func10(). See details below.");
        return impl_->func10(in1);
    }

    uint32_t func11(uint32_t in1) final {
        static_assert(HasFunc11<T>(0), "T cannot be cast to interface TestIntf1: No matching overload for func11(). See details below.");
        return impl_->func11(in1);
    }

    std::tuple<uint32_t, uint32_t> func12(uint32_t in1) final {
        static_assert(HasFunc12<T>(0), "T cannot be cast to interface TestIntf1: No matching overload for func12(). See details below.");
        return impl_->func12(in1);
    }

    void func20(uint32_t in1, uint32_t in2) final {
        static_assert(HasFunc20<T>(0), "T cannot be cast to interface TestIntf1: No matching overload for func20(). See details below.");
        return impl_->func20(in1, in2);
    }

    uint32_t func21(uint32_t in1, uint32_t in2) final {
        static_assert(HasFunc21<T>(0), "T cannot be cast to interface TestIntf1: No matching overload for func21(). See details below.");
        return impl_->func21(in1, in2);
    }

    std::tuple<uint32_t, uint32_t> func22(uint32_t in1, uint32_t in2) final {
        static_assert(HasFunc22<T>(0), "T cannot be cast to interface TestIntf1: No matching overload for func22(). See details below.");
        return impl_->func22(in1, in2);
    }

    T* impl_;
    fibre::Property<const uint32_t> prop_uint32_{&impl_->prop_uint32_};
    fibre::Property<uint32_t> prop_uint32_rw_{&impl_->prop_uint32_rw_};
    TestIntf1_SubobjWrapper<decltype(impl_->subobj_)> subobj_{impl_->subobj_};
};



template<typename T>
struct TestIntf1_SubobjWrapper : TestIntf1_SubobjIntf {
    template<typename U, typename TRet = decltype((uint32_t)std::declval<U>().subfunc())> static constexpr bool HasSubfunc(int) { return true; }
    template<typename U> static constexpr bool HasSubfunc(...) { return false; }

    TestIntf1_SubobjWrapper(T& impl) : impl_(&impl) {}

    uint32_t subfunc() final {
        static_assert(HasSubfunc<T>(0), "T cannot be cast to interface TestIntf1.Subobj: No matching overload for subfunc(). See details below.");
        return impl_->subfunc();
    }

    T* impl_;
};




#endif // __FIBRE_INTERFACES_HPP